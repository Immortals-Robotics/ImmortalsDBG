// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot-feedback.proto

#ifndef PROTOBUF_robot_2dfeedback_2eproto__INCLUDED
#define PROTOBUF_robot_2dfeedback_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_robot_2dfeedback_2eproto();
void protobuf_AssignDesc_robot_2dfeedback_2eproto();
void protobuf_ShutdownFile_robot_2dfeedback_2eproto();

class PID;
class Constans;
class RobotFeedback;

// ===================================================================

class PID : public ::google::protobuf::Message {
 public:
  PID();
  virtual ~PID();

  PID(const PID& from);

  inline PID& operator=(const PID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PID& default_instance();

  void Swap(PID* other);

  // implements Message ----------------------------------------------

  PID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PID& from);
  void MergeFrom(const PID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float P = 1;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 1;
  inline float p() const;
  inline void set_p(float value);

  // required float I = 2;
  inline bool has_i() const;
  inline void clear_i();
  static const int kIFieldNumber = 2;
  inline float i() const;
  inline void set_i(float value);

  // required float D = 3;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 3;
  inline float d() const;
  inline void set_d(float value);

  // @@protoc_insertion_point(class_scope:PID)
 private:
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_i();
  inline void clear_has_i();
  inline void set_has_d();
  inline void clear_has_d();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float p_;
  float i_;
  float d_;
  friend void  protobuf_AddDesc_robot_2dfeedback_2eproto();
  friend void protobuf_AssignDesc_robot_2dfeedback_2eproto();
  friend void protobuf_ShutdownFile_robot_2dfeedback_2eproto();

  void InitAsDefaultInstance();
  static PID* default_instance_;
};
// -------------------------------------------------------------------

class Constans : public ::google::protobuf::Message {
 public:
  Constans();
  virtual ~Constans();

  Constans(const Constans& from);

  inline Constans& operator=(const Constans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Constans& default_instance();

  void Swap(Constans* other);

  // implements Message ----------------------------------------------

  Constans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Constans& from);
  void MergeFrom(const Constans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float gyro_offset = 1;
  inline bool has_gyro_offset() const;
  inline void clear_gyro_offset();
  static const int kGyroOffsetFieldNumber = 1;
  inline float gyro_offset() const;
  inline void set_gyro_offset(float value);

  // optional uint32 button_status = 2;
  inline bool has_button_status() const;
  inline void clear_button_status();
  static const int kButtonStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 button_status() const;
  inline void set_button_status(::google::protobuf::uint32 value);

  // optional .PID pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline const ::PID& pid() const;
  inline ::PID* mutable_pid();
  inline ::PID* release_pid();
  inline void set_allocated_pid(::PID* pid);

  // @@protoc_insertion_point(class_scope:Constans)
 private:
  inline void set_has_gyro_offset();
  inline void clear_has_gyro_offset();
  inline void set_has_button_status();
  inline void clear_has_button_status();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float gyro_offset_;
  ::google::protobuf::uint32 button_status_;
  ::PID* pid_;
  friend void  protobuf_AddDesc_robot_2dfeedback_2eproto();
  friend void protobuf_AssignDesc_robot_2dfeedback_2eproto();
  friend void protobuf_ShutdownFile_robot_2dfeedback_2eproto();

  void InitAsDefaultInstance();
  static Constans* default_instance_;
};
// -------------------------------------------------------------------

class RobotFeedback : public ::google::protobuf::Message {
 public:
  RobotFeedback();
  virtual ~RobotFeedback();

  RobotFeedback(const RobotFeedback& from);

  inline RobotFeedback& operator=(const RobotFeedback& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotFeedback& default_instance();

  void Swap(RobotFeedback* other);

  // implements Message ----------------------------------------------

  RobotFeedback* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotFeedback& from);
  void MergeFrom(const RobotFeedback& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 robot_id = 1;
  inline bool has_robot_id() const;
  inline void clear_robot_id();
  static const int kRobotIdFieldNumber = 1;
  inline ::google::protobuf::uint32 robot_id() const;
  inline void set_robot_id(::google::protobuf::uint32 value);

  // optional float battery_voltage = 2;
  inline bool has_battery_voltage() const;
  inline void clear_battery_voltage();
  static const int kBatteryVoltageFieldNumber = 2;
  inline float battery_voltage() const;
  inline void set_battery_voltage(float value);

  // optional float cap_voltage = 3;
  inline bool has_cap_voltage() const;
  inline void clear_cap_voltage();
  static const int kCapVoltageFieldNumber = 3;
  inline float cap_voltage() const;
  inline void set_cap_voltage(float value);

  // optional bool dribbe_connected = 4;
  inline bool has_dribbe_connected() const;
  inline void clear_dribbe_connected();
  static const int kDribbeConnectedFieldNumber = 4;
  inline bool dribbe_connected() const;
  inline void set_dribbe_connected(bool value);

  // optional bool ball_detected = 5;
  inline bool has_ball_detected() const;
  inline void clear_ball_detected();
  static const int kBallDetectedFieldNumber = 5;
  inline bool ball_detected() const;
  inline void set_ball_detected(bool value);

  // repeated bool motor_fault = 6;
  inline int motor_fault_size() const;
  inline void clear_motor_fault();
  static const int kMotorFaultFieldNumber = 6;
  inline bool motor_fault(int index) const;
  inline void set_motor_fault(int index, bool value);
  inline void add_motor_fault(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      motor_fault() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_motor_fault();

  // repeated bool encoder_fault = 7;
  inline int encoder_fault_size() const;
  inline void clear_encoder_fault();
  static const int kEncoderFaultFieldNumber = 7;
  inline bool encoder_fault(int index) const;
  inline void set_encoder_fault(int index, bool value);
  inline void add_encoder_fault(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      encoder_fault() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_encoder_fault();

  // optional bool gyro_yaw = 8;
  inline bool has_gyro_yaw() const;
  inline void clear_gyro_yaw();
  static const int kGyroYawFieldNumber = 8;
  inline bool gyro_yaw() const;
  inline void set_gyro_yaw(bool value);

  // repeated float motor_vel = 9;
  inline int motor_vel_size() const;
  inline void clear_motor_vel();
  static const int kMotorVelFieldNumber = 9;
  inline float motor_vel(int index) const;
  inline void set_motor_vel(int index, float value);
  inline void add_motor_vel(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      motor_vel() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_motor_vel();

  // repeated float motor_set_point = 10;
  inline int motor_set_point_size() const;
  inline void clear_motor_set_point();
  static const int kMotorSetPointFieldNumber = 10;
  inline float motor_set_point(int index) const;
  inline void set_motor_set_point(int index, float value);
  inline void add_motor_set_point(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      motor_set_point() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_motor_set_point();

  // optional .PID pid = 11;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 11;
  inline const ::PID& pid() const;
  inline ::PID* mutable_pid();
  inline ::PID* release_pid();
  inline void set_allocated_pid(::PID* pid);

  // @@protoc_insertion_point(class_scope:RobotFeedback)
 private:
  inline void set_has_robot_id();
  inline void clear_has_robot_id();
  inline void set_has_battery_voltage();
  inline void clear_has_battery_voltage();
  inline void set_has_cap_voltage();
  inline void clear_has_cap_voltage();
  inline void set_has_dribbe_connected();
  inline void clear_has_dribbe_connected();
  inline void set_has_ball_detected();
  inline void clear_has_ball_detected();
  inline void set_has_gyro_yaw();
  inline void clear_has_gyro_yaw();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 robot_id_;
  float battery_voltage_;
  float cap_voltage_;
  bool dribbe_connected_;
  bool ball_detected_;
  bool gyro_yaw_;
  ::google::protobuf::RepeatedField< bool > motor_fault_;
  ::google::protobuf::RepeatedField< bool > encoder_fault_;
  ::google::protobuf::RepeatedField< float > motor_vel_;
  ::google::protobuf::RepeatedField< float > motor_set_point_;
  ::PID* pid_;
  friend void  protobuf_AddDesc_robot_2dfeedback_2eproto();
  friend void protobuf_AssignDesc_robot_2dfeedback_2eproto();
  friend void protobuf_ShutdownFile_robot_2dfeedback_2eproto();

  void InitAsDefaultInstance();
  static RobotFeedback* default_instance_;
};
// ===================================================================


// ===================================================================

// PID

// required float P = 1;
inline bool PID::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PID::set_has_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PID::clear_has_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PID::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline float PID::p() const {
  // @@protoc_insertion_point(field_get:PID.P)
  return p_;
}
inline void PID::set_p(float value) {
  set_has_p();
  p_ = value;
  // @@protoc_insertion_point(field_set:PID.P)
}

// required float I = 2;
inline bool PID::has_i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PID::set_has_i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PID::clear_has_i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PID::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline float PID::i() const {
  // @@protoc_insertion_point(field_get:PID.I)
  return i_;
}
inline void PID::set_i(float value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:PID.I)
}

// required float D = 3;
inline bool PID::has_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PID::set_has_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PID::clear_has_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PID::clear_d() {
  d_ = 0;
  clear_has_d();
}
inline float PID::d() const {
  // @@protoc_insertion_point(field_get:PID.D)
  return d_;
}
inline void PID::set_d(float value) {
  set_has_d();
  d_ = value;
  // @@protoc_insertion_point(field_set:PID.D)
}

// -------------------------------------------------------------------

// Constans

// optional float gyro_offset = 1;
inline bool Constans::has_gyro_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Constans::set_has_gyro_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Constans::clear_has_gyro_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Constans::clear_gyro_offset() {
  gyro_offset_ = 0;
  clear_has_gyro_offset();
}
inline float Constans::gyro_offset() const {
  // @@protoc_insertion_point(field_get:Constans.gyro_offset)
  return gyro_offset_;
}
inline void Constans::set_gyro_offset(float value) {
  set_has_gyro_offset();
  gyro_offset_ = value;
  // @@protoc_insertion_point(field_set:Constans.gyro_offset)
}

// optional uint32 button_status = 2;
inline bool Constans::has_button_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Constans::set_has_button_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Constans::clear_has_button_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Constans::clear_button_status() {
  button_status_ = 0u;
  clear_has_button_status();
}
inline ::google::protobuf::uint32 Constans::button_status() const {
  // @@protoc_insertion_point(field_get:Constans.button_status)
  return button_status_;
}
inline void Constans::set_button_status(::google::protobuf::uint32 value) {
  set_has_button_status();
  button_status_ = value;
  // @@protoc_insertion_point(field_set:Constans.button_status)
}

// optional .PID pid = 3;
inline bool Constans::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Constans::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Constans::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Constans::clear_pid() {
  if (pid_ != NULL) pid_->::PID::Clear();
  clear_has_pid();
}
inline const ::PID& Constans::pid() const {
  // @@protoc_insertion_point(field_get:Constans.pid)
  return pid_ != NULL ? *pid_ : *default_instance_->pid_;
}
inline ::PID* Constans::mutable_pid() {
  set_has_pid();
  if (pid_ == NULL) pid_ = new ::PID;
  // @@protoc_insertion_point(field_mutable:Constans.pid)
  return pid_;
}
inline ::PID* Constans::release_pid() {
  clear_has_pid();
  ::PID* temp = pid_;
  pid_ = NULL;
  return temp;
}
inline void Constans::set_allocated_pid(::PID* pid) {
  delete pid_;
  pid_ = pid;
  if (pid) {
    set_has_pid();
  } else {
    clear_has_pid();
  }
  // @@protoc_insertion_point(field_set_allocated:Constans.pid)
}

// -------------------------------------------------------------------

// RobotFeedback

// required uint32 robot_id = 1;
inline bool RobotFeedback::has_robot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotFeedback::set_has_robot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotFeedback::clear_has_robot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotFeedback::clear_robot_id() {
  robot_id_ = 0u;
  clear_has_robot_id();
}
inline ::google::protobuf::uint32 RobotFeedback::robot_id() const {
  // @@protoc_insertion_point(field_get:RobotFeedback.robot_id)
  return robot_id_;
}
inline void RobotFeedback::set_robot_id(::google::protobuf::uint32 value) {
  set_has_robot_id();
  robot_id_ = value;
  // @@protoc_insertion_point(field_set:RobotFeedback.robot_id)
}

// optional float battery_voltage = 2;
inline bool RobotFeedback::has_battery_voltage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotFeedback::set_has_battery_voltage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotFeedback::clear_has_battery_voltage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotFeedback::clear_battery_voltage() {
  battery_voltage_ = 0;
  clear_has_battery_voltage();
}
inline float RobotFeedback::battery_voltage() const {
  // @@protoc_insertion_point(field_get:RobotFeedback.battery_voltage)
  return battery_voltage_;
}
inline void RobotFeedback::set_battery_voltage(float value) {
  set_has_battery_voltage();
  battery_voltage_ = value;
  // @@protoc_insertion_point(field_set:RobotFeedback.battery_voltage)
}

// optional float cap_voltage = 3;
inline bool RobotFeedback::has_cap_voltage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotFeedback::set_has_cap_voltage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotFeedback::clear_has_cap_voltage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotFeedback::clear_cap_voltage() {
  cap_voltage_ = 0;
  clear_has_cap_voltage();
}
inline float RobotFeedback::cap_voltage() const {
  // @@protoc_insertion_point(field_get:RobotFeedback.cap_voltage)
  return cap_voltage_;
}
inline void RobotFeedback::set_cap_voltage(float value) {
  set_has_cap_voltage();
  cap_voltage_ = value;
  // @@protoc_insertion_point(field_set:RobotFeedback.cap_voltage)
}

// optional bool dribbe_connected = 4;
inline bool RobotFeedback::has_dribbe_connected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotFeedback::set_has_dribbe_connected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotFeedback::clear_has_dribbe_connected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotFeedback::clear_dribbe_connected() {
  dribbe_connected_ = false;
  clear_has_dribbe_connected();
}
inline bool RobotFeedback::dribbe_connected() const {
  // @@protoc_insertion_point(field_get:RobotFeedback.dribbe_connected)
  return dribbe_connected_;
}
inline void RobotFeedback::set_dribbe_connected(bool value) {
  set_has_dribbe_connected();
  dribbe_connected_ = value;
  // @@protoc_insertion_point(field_set:RobotFeedback.dribbe_connected)
}

// optional bool ball_detected = 5;
inline bool RobotFeedback::has_ball_detected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotFeedback::set_has_ball_detected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotFeedback::clear_has_ball_detected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotFeedback::clear_ball_detected() {
  ball_detected_ = false;
  clear_has_ball_detected();
}
inline bool RobotFeedback::ball_detected() const {
  // @@protoc_insertion_point(field_get:RobotFeedback.ball_detected)
  return ball_detected_;
}
inline void RobotFeedback::set_ball_detected(bool value) {
  set_has_ball_detected();
  ball_detected_ = value;
  // @@protoc_insertion_point(field_set:RobotFeedback.ball_detected)
}

// repeated bool motor_fault = 6;
inline int RobotFeedback::motor_fault_size() const {
  return motor_fault_.size();
}
inline void RobotFeedback::clear_motor_fault() {
  motor_fault_.Clear();
}
inline bool RobotFeedback::motor_fault(int index) const {
  // @@protoc_insertion_point(field_get:RobotFeedback.motor_fault)
  return motor_fault_.Get(index);
}
inline void RobotFeedback::set_motor_fault(int index, bool value) {
  motor_fault_.Set(index, value);
  // @@protoc_insertion_point(field_set:RobotFeedback.motor_fault)
}
inline void RobotFeedback::add_motor_fault(bool value) {
  motor_fault_.Add(value);
  // @@protoc_insertion_point(field_add:RobotFeedback.motor_fault)
}
inline const ::google::protobuf::RepeatedField< bool >&
RobotFeedback::motor_fault() const {
  // @@protoc_insertion_point(field_list:RobotFeedback.motor_fault)
  return motor_fault_;
}
inline ::google::protobuf::RepeatedField< bool >*
RobotFeedback::mutable_motor_fault() {
  // @@protoc_insertion_point(field_mutable_list:RobotFeedback.motor_fault)
  return &motor_fault_;
}

// repeated bool encoder_fault = 7;
inline int RobotFeedback::encoder_fault_size() const {
  return encoder_fault_.size();
}
inline void RobotFeedback::clear_encoder_fault() {
  encoder_fault_.Clear();
}
inline bool RobotFeedback::encoder_fault(int index) const {
  // @@protoc_insertion_point(field_get:RobotFeedback.encoder_fault)
  return encoder_fault_.Get(index);
}
inline void RobotFeedback::set_encoder_fault(int index, bool value) {
  encoder_fault_.Set(index, value);
  // @@protoc_insertion_point(field_set:RobotFeedback.encoder_fault)
}
inline void RobotFeedback::add_encoder_fault(bool value) {
  encoder_fault_.Add(value);
  // @@protoc_insertion_point(field_add:RobotFeedback.encoder_fault)
}
inline const ::google::protobuf::RepeatedField< bool >&
RobotFeedback::encoder_fault() const {
  // @@protoc_insertion_point(field_list:RobotFeedback.encoder_fault)
  return encoder_fault_;
}
inline ::google::protobuf::RepeatedField< bool >*
RobotFeedback::mutable_encoder_fault() {
  // @@protoc_insertion_point(field_mutable_list:RobotFeedback.encoder_fault)
  return &encoder_fault_;
}

// optional bool gyro_yaw = 8;
inline bool RobotFeedback::has_gyro_yaw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RobotFeedback::set_has_gyro_yaw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RobotFeedback::clear_has_gyro_yaw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RobotFeedback::clear_gyro_yaw() {
  gyro_yaw_ = false;
  clear_has_gyro_yaw();
}
inline bool RobotFeedback::gyro_yaw() const {
  // @@protoc_insertion_point(field_get:RobotFeedback.gyro_yaw)
  return gyro_yaw_;
}
inline void RobotFeedback::set_gyro_yaw(bool value) {
  set_has_gyro_yaw();
  gyro_yaw_ = value;
  // @@protoc_insertion_point(field_set:RobotFeedback.gyro_yaw)
}

// repeated float motor_vel = 9;
inline int RobotFeedback::motor_vel_size() const {
  return motor_vel_.size();
}
inline void RobotFeedback::clear_motor_vel() {
  motor_vel_.Clear();
}
inline float RobotFeedback::motor_vel(int index) const {
  // @@protoc_insertion_point(field_get:RobotFeedback.motor_vel)
  return motor_vel_.Get(index);
}
inline void RobotFeedback::set_motor_vel(int index, float value) {
  motor_vel_.Set(index, value);
  // @@protoc_insertion_point(field_set:RobotFeedback.motor_vel)
}
inline void RobotFeedback::add_motor_vel(float value) {
  motor_vel_.Add(value);
  // @@protoc_insertion_point(field_add:RobotFeedback.motor_vel)
}
inline const ::google::protobuf::RepeatedField< float >&
RobotFeedback::motor_vel() const {
  // @@protoc_insertion_point(field_list:RobotFeedback.motor_vel)
  return motor_vel_;
}
inline ::google::protobuf::RepeatedField< float >*
RobotFeedback::mutable_motor_vel() {
  // @@protoc_insertion_point(field_mutable_list:RobotFeedback.motor_vel)
  return &motor_vel_;
}

// repeated float motor_set_point = 10;
inline int RobotFeedback::motor_set_point_size() const {
  return motor_set_point_.size();
}
inline void RobotFeedback::clear_motor_set_point() {
  motor_set_point_.Clear();
}
inline float RobotFeedback::motor_set_point(int index) const {
  // @@protoc_insertion_point(field_get:RobotFeedback.motor_set_point)
  return motor_set_point_.Get(index);
}
inline void RobotFeedback::set_motor_set_point(int index, float value) {
  motor_set_point_.Set(index, value);
  // @@protoc_insertion_point(field_set:RobotFeedback.motor_set_point)
}
inline void RobotFeedback::add_motor_set_point(float value) {
  motor_set_point_.Add(value);
  // @@protoc_insertion_point(field_add:RobotFeedback.motor_set_point)
}
inline const ::google::protobuf::RepeatedField< float >&
RobotFeedback::motor_set_point() const {
  // @@protoc_insertion_point(field_list:RobotFeedback.motor_set_point)
  return motor_set_point_;
}
inline ::google::protobuf::RepeatedField< float >*
RobotFeedback::mutable_motor_set_point() {
  // @@protoc_insertion_point(field_mutable_list:RobotFeedback.motor_set_point)
  return &motor_set_point_;
}

// optional .PID pid = 11;
inline bool RobotFeedback::has_pid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RobotFeedback::set_has_pid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RobotFeedback::clear_has_pid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RobotFeedback::clear_pid() {
  if (pid_ != NULL) pid_->::PID::Clear();
  clear_has_pid();
}
inline const ::PID& RobotFeedback::pid() const {
  // @@protoc_insertion_point(field_get:RobotFeedback.pid)
  return pid_ != NULL ? *pid_ : *default_instance_->pid_;
}
inline ::PID* RobotFeedback::mutable_pid() {
  set_has_pid();
  if (pid_ == NULL) pid_ = new ::PID;
  // @@protoc_insertion_point(field_mutable:RobotFeedback.pid)
  return pid_;
}
inline ::PID* RobotFeedback::release_pid() {
  clear_has_pid();
  ::PID* temp = pid_;
  pid_ = NULL;
  return temp;
}
inline void RobotFeedback::set_allocated_pid(::PID* pid) {
  delete pid_;
  pid_ = pid;
  if (pid) {
    set_has_pid();
  } else {
    clear_has_pid();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotFeedback.pid)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_robot_2dfeedback_2eproto__INCLUDED
